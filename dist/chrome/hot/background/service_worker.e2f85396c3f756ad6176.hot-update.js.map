{"version":3,"file":"hot/background/service_worker.e2f85396c3f756ad6176.hot-update.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrTA","sources":["webpack://sideklick-extension/./background.ts","webpack://sideklick-extension/webpack/runtime/getFullHash"],"sourcesContent":["__webpack_require__.$Refresh$.runtime = require('/home/oussama/personal/sideklick-extension/node_modules/react-refresh/runtime.js');\n\n;\nchrome.runtime.onMessageExternal.addListener(async (request, _sender, sendResponse) => {\n  const managementInfo = await new Promise(resolve => {\n    chrome.management.getSelf(resolve);\n  });\n\n  // Ping-pong between the user extension background page(this)\n  // and the middleware socket client (reloadService.ts),\n  // which will then send a message to the server\n  // (startServer.ts) so it can display the extension info.\n  if (request.initialLoadData) {\n    sendResponse({\n      id: chrome.runtime.id,\n      manifest: chrome.runtime.getManifest(),\n      management: managementInfo\n    });\n    return true;\n  }\n\n  // Reload the extension runtime if the manifest or\n  // service worker changes. \n  if (request.changedFile === 'manifest.json' || request.changedFile === 'service_worker' || request.changedFile === '_locales') {\n    setTimeout(() => {\n      sendResponse({\n        reloaded: true\n      });\n      chrome.runtime.reload();\n    }, 750);\n  }\n\n  // Reload all tabs if the contextMenus code changes.\n  if (request.changedFile === 'contextMenus') {\n    sendResponse({\n      reloaded: true\n    });\n    chrome.tabs.query({}, tabs => {\n      if (!tabs) return;\n      tabs.forEach(tab => chrome.tabs.reload(tab.id));\n    });\n  }\n\n  // Reload all tabs if the declarative_net_request code changes.\n  if (request.changedFile === 'declarative_net_request') {\n    sendResponse({\n      reloaded: true\n    });\n    chrome.runtime.reload();\n  }\n  return true;\n});\n// import { GoogleGenerativeAI } from \"@google/generative-ai\";\n// import { GoogleGenerativeAI } from './node_modules/@google/generative-ai/dist/index.mjs';\n\nconsole.log(\"Hello from the background script!\");\n\n// async function promptGemini(systemPrompt: string, userPrompt: string): Promise<string> {\n//     console.log(\"prompting gemini\")\n//     return new Promise((resolve) => {\n//         chrome.storage.sync.get(\"apiKey\", async (result) => {\n//             const apiKey = result.apiKey;\n//             if (!apiKey) {\n//                 console.error(\"API key is not set\");\n//                 resolve(\"\"); // Return empty string if no API key\n//                 return;\n//             }\n\n//             const genAI = new GoogleGenerativeAI(apiKey);\n//             const model = genAI.getGenerativeModel({\n//                 model: \"gemini-1.5-flash\",\n//                 systemInstruction: systemPrompt,\n//             });\n\n//             const res = await model.generateContent(userPrompt);\n//             const response = await res.response;\n//             const text = response.text();\n//             console.log(`gemini response: ${text}`);\n//             resolve(text); // Resolve with the generated text\n//         });\n//     });\n// }\n\nconst builtinMenus = [{\n  id: \"uppercase\",\n  title: \"Uppercase\",\n  function: uppercaseSelectedText\n}, {\n  id: \"lowercase\",\n  title: \"Lowercase\",\n  function: lowercaseSelectedText\n}, {\n  id: \"capitalize\",\n  title: \"Capitalize\",\n  function: capitalizeSelectedText\n}, {\n  id: \"fixTypos\",\n  title: \"Fix Typos\",\n  function: fixTypos\n}, {\n  id: \"fixGrammar\",\n  title: \"Fix Grammar\",\n  function: fixGrammar\n}];\nlet customMenus = [];\nclass CustomMenu {\n  // Change 'function' to 'func' and specify the type\n\n  constructor(id, title, prompt) {\n    this.id = id;\n    this.title = title;\n    this.prompt = prompt;\n    this.function = this.executeFunction;\n  }\n  async executeFunction() {\n    const selectedText = window.getSelection()?.toString() || \"\";\n    const systemPrompt = `You are a writing assistant, you are given a text and you have to ${this.prompt} in the same language as the input and reply with ONLY the fixed text`;\n    console.log(`calling prompt gemini with custom prompt`);\n    const response = await promptGemini(systemPrompt, selectedText);\n    document.execCommand(\"insertText\", false, response);\n  }\n}\nchrome.runtime.onInstalled.addListener(details => {\n  if (details.reason !== \"install\" && details.reason !== \"update\") return;\n  chrome.contextMenus.create({\n    id: \"sideClickParent\",\n    title: \"SideKlickCrxjs\",\n    contexts: [\"selection\"]\n  });\n  builtinMenus.forEach(menu => {\n    chrome.contextMenus.create({\n      id: menu.id,\n      parentId: \"sideClickParent\",\n      title: menu.title,\n      contexts: [\"selection\"]\n    });\n  });\n});\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n  const menuItem = builtinMenus.find(menu => menu.id === info.menuItemId) || customMenus.find(menu => menu.id === info.menuItemId);\n  if (menuItem && menuItem.function) {\n    try {\n      if (tab && tab.id !== undefined) {\n        // Ensure tab.id is defined\n        chrome.scripting.executeScript(r.solve({\n          target: {\n            tabId: tab.id\n          },\n          func: menuItem.function // Change 'function' to 'func'\n        }));\n      } else {\n        console.error(\"Tab ID is undefined\");\n      }\n    } catch (error) {\n      console.error(\"Error executing function:\", error);\n    }\n  }\n});\nasync function uppercaseSelectedText() {\n  const selectedText = window.getSelection()?.toString();\n  document.execCommand(\"insertText\", false, selectedText?.toUpperCase());\n}\nasync function lowercaseSelectedText() {\n  const selectedText = window.getSelection()?.toString();\n  document.execCommand(\"insertText\", false, selectedText?.toLowerCase());\n}\nasync function capitalizeSelectedText() {\n  const selectedText = window.getSelection()?.toString();\n  const replacement = (selectedText?.charAt(0).toUpperCase() ?? \"\") + (selectedText?.slice(1).toLowerCase() ?? \"\");\n  document.execCommand(\"insertText\", false, replacement);\n}\nasync function fixTypos() {\n  const selectedText = window.getSelection()?.toString();\n\n  // Get the API key from storage\n  chrome.storage.sync.get(\"apiKey\", async result => {\n    const apiKey = result.apiKey;\n    if (!apiKey) {\n      console.error(\"API key is not set\");\n      return;\n    }\n    const systemPrompt = \"You are a writing assistant, you are given a text and you have to fix grammar and typos in that text IN THE SAME LANGUAGE AS THE INPUT and reply with ONLY THE FIXED TEXT\";\n\n    // Make the request to the Gemini API\n    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;\n    const data = {\n      system_instruction: {\n        parts: {\n          text: systemPrompt\n        }\n      },\n      safetySettings: [{\n        category: 7,\n        threshold: 4\n      }],\n      contents: [{\n        parts: [{\n          text: `${selectedText}`\n        }]\n      }]\n    };\n    let modifiedText = selectedText;\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(data)\n      });\n      const result = await response.json();\n      console.log(result);\n      modifiedText = result.candidates[0].content.parts[0].text.trim();\n    } catch (error) {\n      console.error(\"Error prompting Gemini:\", error);\n    }\n    try {\n      document.execCommand(\"insertText\", false, modifiedText);\n    } catch (error) {\n      console.error(\"Error modifying text:\", error);\n    }\n  });\n}\nasync function fixGrammar() {\n  const selectedText = window.getSelection()?.toString();\n  const systemPrompt = \"You are a writing assistant, you are given a text and you have to fix grammar in that text in the same language as the input and reply with ONLY the fixed text and NO ADDITIONAL WHITESPACE\";\n  console.log(`calling prompt gemini`);\n  const response = (await promptGemini(systemPrompt, selectedText || \"\")) || \"\"; // Ensure response is a string\n  document.execCommand(\"insertText\", false, response);\n}\nasync function promptGemini(systemPrompt, selectedText) {\n  console.log(`prompting gemini`);\n  const apiKey = await chrome.storage.local.get(\"apiKey\");\n  if (!apiKey) {\n    console.error(\"API key is not set\");\n    return;\n  }\n  // Make the request to the Gemini API\n  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;\n  const data = {\n    system_instruction: {\n      parts: {\n        text: systemPrompt\n      }\n    },\n    contents: [{\n      parts: [{\n        text: `${selectedText}`\n      }]\n    }]\n  };\n  let modifiedText;\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data)\n    });\n    const result = await response.json();\n    modifiedText = result.candidates[0].content.parts[0].text.trim();\n    return modifiedText;\n  } catch (error) {\n    console.error(\"Error prompting Gemini:\", error);\n  }\n}\nconst moreProfessional = new CustomMenu(\"morePro\", \"more professional\", \"make it more professional\");\nchrome.contextMenus.update(\"sideClickParent\", {}, () => {\n  customMenus.forEach(menu => {\n    chrome.contextMenus.create({\n      id: menu.id,\n      // parentId: \"sideClickParent\",\n      title: menu.title,\n      contexts: [\"selection\"]\n    });\n  });\n});\nexport {};\n\nconst $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;\nconst $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(\n\t$ReactRefreshModuleId$\n);\n\nfunction $ReactRefreshModuleRuntime$(exports) {\n\tif (module.hot) {\n\t\tlet errorOverlay;\n\t\tif (typeof __react_refresh_error_overlay__ !== 'undefined') {\n\t\t\terrorOverlay = __react_refresh_error_overlay__;\n\t\t}\n\t\tlet testMode;\n\t\tif (typeof __react_refresh_test__ !== 'undefined') {\n\t\t\ttestMode = __react_refresh_test__;\n\t\t}\n\t\treturn __react_refresh_utils__.executeRuntime(\n\t\t\texports,\n\t\t\t$ReactRefreshModuleId$,\n\t\t\tmodule.hot,\n\t\t\terrorOverlay,\n\t\t\ttestMode\n\t\t);\n\t}\n}\n\nif (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {\n\t$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);\n} else {\n\t$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);\n}","__webpack_require__.h = () => (\"cd7e79664ec65f3e9a05\")"],"names":[],"sourceRoot":""}